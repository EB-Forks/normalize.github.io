<!DOCTYPE html><html><head><title>normalize.io - an ES6 module, Web Component, and SPDY/HTTP2 Push frontend development worfklow</title><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui"><link rel="stylesheet" href="index.css"><link rel="stylesheet" href="https://yandex.st/highlightjs/8.0/styles/github.min.css"></head><body><div id="top-bar"><div class="container"><a id="top-bar-logo" href="./">nlz.io</a><a href="https://github.com/normalize/discussions" class="top-bar-link">discuss</a><a href="faq.html" class="top-bar-link">faq</a><a href="guide.html" class="top-bar-link">guide</a><a href="api.html" class="top-bar-link">api</a></div></div><header><div class="container"><h1>FAQ</h1></div></header><main><section><div class="container"><h3 id="how-does-normalize-io-compare-to-other-similar-client-side-tools-">How does Normalize.IO compare to other similar client-side tools?</h3>
<p>Normalize&#39;s philosophy drastically differs from most client-side tools today, both ES6 and pre-ES6.
Perhaps the biggest difference is that Normalize aims to solve the entire frontend web development via vertical integration,
whereas most tools aim to solve only a particular aspect of frontend development.</p>
<p>The two major ES6 client-side tools I know of are <a href="http://jspm.io">jspm.io</a> and <a href="http://stealjs.com/docs/index.html">stealjs</a>.
Normalize differs in that:</p>
<ul>
<li>Unlike jspm.io, Normalize never advocates using <code>System</code> and instead only advocates using <code>import</code>s and <code>export</code>s.
Using <code>System</code>, which is async, is not much of an improvement over AMD.</li>
<li>Unlike both, Normalize avoids any client-side complexities and overhead with runtimes such as <a href="https://github.com/ModuleLoader/es6-module-loader">ES6 module loader</a>,
making it more suitable for production usage.</li>
<li>Normalize aims to rid the frontend development workflow from install and build steps.
StealJS requires you to download packages from Bower as well as setup your own Grunt build process.</li>
</ul>
<p>Normalize is more similar to Component and Browserify except it automatically infers the manifest and dependency tree
via static analysis. With CommonJS, this was more difficult as <code>require()</code>s are just functions and
not precisely static. Like both Component and Bower, Normalize supports CSS and HTML as first class citizens.</p>
<p>Bundlers such as Browserify and Webpack are focused on JS and require other assets
to be loaded via JS. This is more suitable for JS-heavy sites such as games,
but is not suitable for design-heavy apps.</p>
<p>A feature of many bundlers such as Browserify and Webpack is the ability to create multiple bundles.
However, Normalize does not and will not bother with bundling as it will become irrelevant with SPDY/HTTP2.</p>
<h3 id="when-shouldn-t-i-use-normalize-io-">When shouldn&#39;t I use Normalize.IO?</h3>
<p>As Normalize aims to rid your workflow of custom build processes,
there must be some cases where Normalize fails to meet your needs.
In particular, anything that requires concatenation won&#39;t be suitable for Normalize.
This includes:</p>
<ul>
<li>Any build task that are many-to-one such as concatenation (CSS preprocessors) or combining (creating sprite sheets).
CSS preprocessors such as SASS and LESS that depend on &quot;global&quot; features such as variables, mixins, and inheritance,
which requires concatenation.
Variables can be replaced by CSS variables, but mixins and inheritance can not be replaced with vanilla CSS.
Instead, point Normalize to the &quot;final&quot; output instead of the source files.</li>
<li>AMD environments as Normalize will not attempt to support such modules.</li>
</ul>
<h3 id="will-normalize-io-support-node-js-">Will Normalize.IO support node.js?</h3>
<p>Normalize.IO is specifically tailored for frontend development.
In particular, node modules are refactored to work for the browser,
sacrificing node compatibility in the process.</p>
<p>Instead, we will most likely make a similar tool for node.js,
but it may not be the same name or in the same utility.</p>
<h3 id="can-i-omit-http-or-https-from-the-urls-">Can I omit <code>http:</code> or <code>https://</code> from the URLs?</h3>
<p>If browsers support protocol-less URLs, then so will we.
However, there are a couple potential issues with omitting protocols.</p>
<ol>
<li>It&#39;s more difficult to differentiate between URLs and local/relative assets.</li>
<li>Some browsers plan to not support non-SSL SPDY, so this might not even work in development.</li>
</ol>
</div></section></main><footer><div class="container"><div id="footer-badges"><script data-gittip-username="jonathanong" src="https://gttp.co/v1.js" async></script></div><ul id="footer-links"><li>Jonathan Ong &copy; 2014</li><li><a href="http://jongleberry.com">jongleberry.com</a></li><li><a href="https://github.com/jonathanong">@jonathanong</a></li><li><a href="https://twitter.com/jongleberry">@jongleberry</a></li><li><a href="mailto:me@jongleberry.com">me@jongleberry.com</a></li></ul></div></footer><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-7367759-13', 'normalize.github.io');
ga('send', 'pageview');
</script><script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script><script src="index.js"></script></body></html>