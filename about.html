<!DOCTYPE html><html><head><title>normalize.io - the end of package management for the web</title><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui"><link rel="stylesheet" href="index.css"><link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css"></head><body><div id="top-bar"><div class="container"><a id="top-bar-logo" href="./">nlz.io</a><a href="https://github.com/normalize/discussions" class="top-bar-link">discuss</a><a href="https://github.com/normalize" class="top-bar-link">source</a><a href="guide.html" class="top-bar-link">guide</a><a href="api.html" class="top-bar-link">api</a><a href="about.html" class="top-bar-link">about</a></div></div><header><div class="container"><h1>About</h1></div></header><main><div id="toc" class="Dropdown right down"><a href="#" class="Dropdown-toggle">#</a><div class="Dropdown-menu"></div></div><section><div class="container"><h2 id="philosophy">Philosophy</h2><p>Normalize.IO was born out of frustration with the current web development workflow.
It has a very specific philosophy,
which will affect its development.</p>
<p>Wondering if Normalize.IO should add a feature?
If it complies with these tenets, then let us know!
Otherwise, don&#39;t bother.</p>
<h3 id="back-to-the-basics">Back to the Basics</h3>
<p>The web development stack should be as short as possible.
This means no unnecessary abstractions or opinions and just use what W3C, WHATWG, and ES has given us.
Build tools like LESS, CoffeeScript, and Grunt are second-class citizens.</p>
<p>Let&#39;s not try to build the ideal stack of <code>npm + browserify + less + rework-npm + gulp + yeoman</code>, etc.
We should strive towards <strong>no stack</strong> using only features browsers (will) support,
and at most 1 tool, <code>nlz</code> or anything similar, as a stopgap until browsers get us there.</p>
<h3 id="specification-compliant">Specification Compliant</h3>
<p>Normalize.IO will strive to comply with specifications from the web authorities,
particularly ECMAScript, WHATWG, and W3C.
Specifications like CommonJS, AMD, and UMD are completely irrelevant and are only used as stopgaps for the true specifications.</p>
<p>Thus, you may see features such as <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables">CSS Variables</a> and <a href="http://facebook.github.io/regenerator/">regenerator</a> automatically included, acting like polyfills.
But you will not see features such as <a href="https://github.com/reworkcss/rework-inherit">@extend</a> included unless they are added to the specifications, even as a draft.</p>
<h3 id="opt-in-everything">Opt-In Everything</h3>
<p>Many build systems such as <code>grunt</code>, <code>gulp</code>, <code>broccoli</code>, <code>browserify</code>, and <code>component</code> have a lot of possible plugins and configuration options.
However, these have become a bane for web development as now users have to install tens of modules just to get their app running
as well as figure out how to configure all these plugins to work with each other with giant configuration scripts.
Developers would also have to write plugins for every time of platform,
creating what I call &quot;module pollution&quot;.</p>
<p>The Normalize.IO philosophy is the opposite - it should include all plugins that 99% of web developers use,
allowing most to be able to just simply <code>nlz build --watch</code> their component or app and call it a day.
Eventually, they should be able to skip <code>nlz</code> and simply <code>open webpage.html</code>.
Bootstrapping apps and components should not be complicated.</p>
<p>This means that Normalize.IO will marginalize those 1% of developers who want something very specific and most likely outside of specifications.
If the 1% wishes to use Normalize.IO, they would have to essentially create their own custom proxy and client to do so.
Otherwise, they could use the many other build tools at their disposal.</p>
<h3 id="normalize-web-development">Normalize Web Development</h3>
<p>Aside from the top three tenets,
the idea behind Normalize.IO is to &quot;normalize&quot; or &quot;standardize&quot; web development.
We want to keep features specification compliant and (cognitive) overhead minimal.</p>
<p>But of course, this means normalizing and standardizing how apps and components are built and structured.
This is the primary concept behind <code>entrypoints</code> such as <code>index.js</code>, <code>test.js</code>, <code>README</code>, etc.
People should know what to expect from a &quot;normal&quot; app/module/component.</p>
<h3 id="1-to-1-transformations">1-to-1 Transformations</h3>
<p>One of the most complicated type of transform are many-to-1 transforms.
For example, concatenating all your SCSS files, then converting it to a single CSS file.
However there are many wrong with this philosophy.</p>
<p>Normalize.IO will only support 1-to-1 transformations except for a few cases,
but most likely with caveats.</p>
<h4 id="file-interdependence">File Interdependence</h4>
<p>The only dependencies files should have upon each other are those defined by specifications such as <code>@import</code>.
Anything else is too opinionated for Normalize.IO.
With CSS preprocessors, this may be necessary when using mixins, variables, etc.,
but you should instead strive towards specifications such as <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables">CSS Variables</a>.</p>
<h4 id="no-incremental-builds">No Incremental Builds</h4>
<p>Only supporting 1-to-1 transformations allow very fast build times through incremental builds.
<code>nlz</code> uses <code>make</code>-like 1-to-1 transforms and only rebuilds source files that have changed.
When you have many-to-one transforms, 1 line change would require a full rebuild.
The difference is a <code>x * 100ms</code> vs. <code>&lt; 100ms</code> build times,
especially with CSS preprocessors such as Stylus and SASS.</p>
<h4 id="no-complicated-build-process">No Complicated Build Process</h4>
<p>Many build tools such as <code>grunt</code>, <code>gulp</code>, and <code>broccoli</code> were created out of a need to support these types of transforms.
In the end, you create very complex build processes and configuration options,
all of which is unnecessary and not specification-compliant.</p>
</div></section><section><div class="container"><h2 id="comparisons">Comparisons</h2><p>Normalize&#39;s philosophy drastically differs from most client-side tools today, both ES6 and pre-ES6.
Perhaps the biggest difference is that Normalize aims to solve <strong>almost everything</strong>
about frontend web development, whereas most tools aim to solve a particular aspect of frontend development.</p>
<p>The two major ES6 client-side tools I know of are <a href="http://jspm.io">jspm.io</a> and <a href="http://stealjs.com/docs/index.html">stealjs</a>.
Normalize differs in that:</p>
<ul>
<li>Unlike jspm.io, Normalize never advocates using <code>System</code> and instead only advocates using <code>import</code>s and <code>export</code>s.
Using <code>System</code>, which is async, is not much of an improvement over AMD.</li>
<li>Unlike both, Normalize avoids any client-side complexities and overhead with runtimes such as <a href="https://github.com/ModuleLoader/es6-module-loader">ES6 module loader</a>,
making it more suitable for production usage.</li>
<li>Normalize aims to rid the frontend development workflow from install and build steps.
StealJS requires you to download packages from Bower as well as setup your own Grunt build process.</li>
</ul>
<p>Normalize is more similar to Component except it automatically infers the manifest and dependency tree
via static analysis. With CommonJS, this was more difficult as <code>require()</code>s are just functions and
not precisely static. Also like both Component and Bower, Normalize supports CSS and HTML as first class citizens.</p>
<p>Other bundlers such as Browserify and Webpack are focused on JS and require other assets
to be loaded via JS. This is more suitable for JS-heavy sites such as games,
but is not suitable for design-heavy apps.</p>
<p>A feature of many bundlers such as browserify and webpack are the ability to create multiple bundles.
However, Normalize does not and will not bother with such features as they are irrelevant with SPDY.
If the client doesn&#39;t need a particular file, then it won&#39;t request it, or it will cancel the SPDY push stream.</p>
<p>As Normalize aims to rid your workflow of custom build processes,
there must be some cases where Normalize fails to meet your app&#39;s needs.
In particular, anything that requires concatenation won&#39;t be suitable for Normalize.
This includes:</p>
<ul>
<li>Any build task that are many-to-one such as concatenation (CSS preprocessors) or combining (creating sprite sheets).
CSS preprocessors such as SASS and LESS that depend on &quot;global&quot; features such as variables, mixins, and inheritance,
which requires concatenation.
Variables can be replaced by CSS variables, but mixins and inheritance can not be replaced with vanilla CSS.
Instead, point Normalize to the &quot;final&quot; output instead of the source files.</li>
<li>AMD environments as Normalize will not attempt to support such modules.</li>
<li>Locale support, particularly translations and RTL. We intend to support these, but we&#39;re not
sure what the best course of action is, so if your company needs these now, you might want to wait on Normalize.</li>
</ul>
</div></section><section><div class="container"><h2 id="faq">Frequently Asked Questions</h2><h3 id="will-normalize-io-support-node-js-">Will Normalize.IO support node.js?</h3>
<p>Normalize.IO is specifically tailored for frontend development.
In particular, node modules are refactored to work for the browser,
sacrificing node compatibility in the process.</p>
<p>Instead, we weill most likely make a similar tool for node.js,
but it may not be the same name or in the same utility.</p>
<h3 id="can-i-omit-http-or-https-from-the-urls-">Can I omit <code>http:</code> or <code>https://</code> from the URLs?</h3>
<p>If browsers support protocol-less URLs, then so will we.
However, there are a couple potential issues with omitting protocols.</p>
<ol>
<li>It&#39;s more difficult to differentiate between URLs and local/relative assets.</li>
<li>Some browsers plan to not support non-SSL SPDY, so this might not even work in development.</li>
</ol>
</div></section></main><footer><div class="container"><div id="footer-badges"><script data-gittip-username="jonathanong" src="https://gttp.co/v1.js" async></script></div><ul id="footer-links"><li>Jonathan Ong &copy; 2014</li><li><a href="http://jongleberry.com">jongleberry.com</a></li><li><a href="https://github.com/jonathanong">@jonathanong</a></li><li><a href="https://twitter.com/jongleberry">@jongleberry</a></li><li><a href="mailto:me@jongleberry.com">me@jongleberry.com</a></li></ul></div></footer><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-7367759-13', 'normalize.github.io');
ga('send', 'pageview');
</script><script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script><script src="index.js"></script></body></html>