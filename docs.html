<!DOCTYPE html><html><head><title>normalize.io - the end of package management for the web</title><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui"><link rel="stylesheet" href="index.css"><link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/github.min.css"></head><body><div id="top-bar"><div class="container"><a id="top-bar-logo" href="./">nlz.io</a><a href="https://github.com/normalize/discussions" class="top-bar-link">discuss</a><a href="https://github.com/normalize" class="top-bar-link">source</a><a href="docs.html" class="top-bar-link">docs</a></div></div><header><div class="container"><h1>Documentation</h1></div></header><main><div id="toc" class="Dropdown right down"><a href="#" class="Dropdown-toggle">#</a><div class="Dropdown-menu"></div></div><section><div class="container"><h2 id="triage">Triage</h2><p>Normalize is split into multiple repositories.
Most of these repositories can be found within the <a href="https://github.com/normalize">normalize GitHub organization</a>.
When requesting features or reporting bugs,
please try to open an issue in the correct repository.</p>
<ul>
<li><a href="https://github.com/normalize/discussions">discussions</a> - a repository for any general discussions.
Don&#39;t know where to open an issue?
Want to ask for support?
Open an issue here.</li>
<li><a href="https://github.com/normalize/normalize.github.io">normalize.github.io</a> - this Normalize.IO homepage and documentation</li>
<li><a href="https://github.com/normalize/proxy.js">proxy.js</a> - the normalization proxy</li>
<li><a href="https://github.com/normalize/nlz">nlz</a> - the command line <code>nlz(1)</code> utility</li>
<li><a href="https://github.com/normalize/transforms.js">transforms.js</a> - all the transforms supported by both the proxy and <code>nlz(1)</code></li>
</ul>
</div></section><section><div class="container"><h2 id="proxy">Normalization Proxy</h2><p>This is the public HTTP API for <a href="https://nlz.io">https://nlz.io</a> as well as any <a href="https://github.com/normalize/proxy.js">normalize-proxy</a>.
If you&#39;re interested in setting up your own proxy,
consult the <a href="https://github.com/normalize/proxy.js">normalize-proxy repository</a>.</p>
<h3 id="url-structure">URL Structure</h3>
<p>URLs generally have the form:</p>
<pre><code>https://nlz.io/<span class="hljs-tag">&lt;<span class="hljs-title">remote</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-title">user</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-title">project</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-title">version</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-title">file</span>&gt;</span>
</code></pre><p>Obviously, different proxies will have different hostnames.
The <code>version</code> and <code>file</code> may not be included in some end points.</p>
<h4 id="protocol">Protocol</h4>
<p>Every proxy <strong>must</strong> serve via HTTPS and SPDY/HTTPv2,
even with a self-signed certificate.</p>
<h4 id="remote">Remote</h4>
<p>A supported remote&#39;s name, for example <code>github/</code>.</p>
<p>Aliases will also be supported and will simply redirect to the canonical short name.
For example, <code>github.com</code> and <code>raw.githubusercontent.com</code> would redirect to <code>github</code>.</p>
<h4 id="user">User</h4>
<p>The owner of a repository.
If the remote does not have a namespace, the user should simply be <code>-</code>.</p>
<pre><code class="lang-bash"><span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/nlz.io/npm</span><span class="hljs-regexp">/-/escape</span>-regexp/*<span class="hljs-regexp">/index.js</span>
</code></pre>
<h4 id="project">Project</h4>
<p>The name of the project or module.</p>
<h4 id="version">Version</h4>
<p>Any version as defined by <a href="http://semver.org">http://semver.org</a> v2.0.0.
You should not include leading <code>v</code>s and <code>=</code> in single versions</p>
<p>Eventually, commit SHAs for <code>git</code> remotes will be supported.
However, branches will never be supported.</p>
<h3 id="api-end-points">API End Points</h3>
<h4 id="get-file">GET File</h4>
<p>You may still <code>GET</code> files directly, even with transforms.
All of the files&#39; dependencies will be SPDY pushed to the client.
A redirect may be returned as a response.
If this is the case, the redirect location will be SPDY pushed as well.</p>
<p>Each file can have the following query strings.
These are only valid when <strong>exact</strong>, so don&#39;t include a trailing <code>=</code>.
Only one query string can be used at a time:</p>
<ul>
<li><code>?source</code> - return/redirect the source file and its dependencies all without any transformations applied. Useful for building server-side.</li>
<li><code>?min</code> - minify the transformation. Only applies to JS, CSS, and HTML assets.</li>
</ul>
<p>If any of these query strings are included,
then all the pushed dependencies will also include the same query string.</p>
<p>Each file will have an <code>ETag</code> header which is the <code>sha256</code> sum of the <strong>source</strong> file.
Thus, the only real way to verify whether this header is correct is to check the <code>?source</code> file.
The ETag will remain the same between query strings and differences in transforms</p>
<p>Note that the ETag header is subject to change as this is obviously less than ideal.</p>
<h4 id="get-pull">GET pull</h4>
<pre><code>GET https://nlz.io/<span class="hljs-tag">&lt;<span class="hljs-title">remote</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-title">user</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-title">project</span>&gt;</span>/pull
</code></pre><p>This will <code>pull</code> a specific version from the remote if it has not be installed already.
If successful, a <code>204</code> status code will be returned.
You may consider this the optional &quot;publish&quot; step of Normalize.IO.</p>
<h4 id="get-versions-json">GET versions.json</h4>
<pre><code>GET https://nlz.io/<span class="hljs-tag">&lt;<span class="hljs-title">remote</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-title">user</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-title">project</span>&gt;</span>/versions.json
</code></pre><p>Will return an array of versions that are currently available on the proxy.
If no versions are installed,
a <code>404</code> and an empty array will be returned.</p>
<p>If you pushed a new version of a package,
but the proxy has not installed it yet,
simply install it by hitting the <code>pull</code> entry point or <code>GET</code> any file.</p>
<p>The semantics of this endpoint is subject to change.
In particular, it should return all available versions on the remote.</p>
<h4 id="get-metadata-json">GET metadata.json</h4>
<pre><code>GET https://nlz.io/<span class="hljs-tag">&lt;<span class="hljs-title">remote</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-title">user</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-title">project</span>&gt;</span>/metadata.json
</code></pre><p>Per-repository metadata that is not version-specific.
This is where you&#39;ll find metadata such as author, keywords, etc.</p>
<blockquote>
<p>Note: not yet implemented.</p>
</blockquote>
<h4 id="get-search-json">GET search.json</h4>
<pre><code>GET https://nlz.io/search.json?<span class="hljs-keyword">...</span>
</code></pre><p>Search the proxy&#39;s installed files and projects.
All search parameters should be passed as query string parameters.
These may include:</p>
<ul>
<li><code>remote</code></li>
<li><code>user</code>/<code>owner</code>/<code>organization</code></li>
<li><code>project</code>/<code>repository</code></li>
<li><code>keywords</code></li>
</ul>
<blockquote>
<p>Note: not yet implemented.</p>
</blockquote>
<h4 id="get-proxy-json">GET proxy.json</h4>
<pre><code class="lang-js">GET https://nlz<span class="hljs-preprocessor">.io</span>/proxy<span class="hljs-preprocessor">.json</span>
</code></pre>
<p>Returns relevant information about the proxy including hostname, version, and supported remotes.</p>
<h3 id="normalization">Normalization</h3>
<p>Packages are &quot;normalized&quot; based on these JSON files in descending priority.</p>
<ol>
<li><code>component.json</code></li>
<li><code>package.json</code></li>
<li><code>bower.json</code></li>
</ol>
<p>This is particularly important if you compile your module for one package manager but not the others.
Thus, if you have to compile your module for a package manager,
compile it for <code>bower</code>.</p>
<h4 id="package-json">package.json</h4>
<p>Only <code>npm</code> and <code>github</code>-style dependencies are supported.
Only semantic versions are supported - versions that have weird suffixes will be ignored.
Other types of dependencies such as tarballs will be ignored.</p>
<h4 id="circular-dependencies">Circular Dependencies</h4>
<p>Modules that must be normalized and have circular dependencies are not supported.
In fact, these modules may actually mess up the proxy.
Please don&#39;t create circular dependencies!
Use <code>devDependencies</code> or something instead.</p>
<h3 id="module-classification">Module Classification</h3>
<p>The normalization proxy is currently designed primarily for web components and modules.
Thus, it needs a way to classify whether a module is web-compatible.
Currently, classification is defined by the following criteria:</p>
<ul>
<li><code>index.html</code> exists</li>
<li><code>index.css</code> exists</li>
<li><code>component.json</code> exists</li>
<li><code>bower.json</code> exists</li>
<li><p><code>package.json</code>:</p>
<ul>
<li><code>.browser</code> exists</li>
<li><code>.style</code> exists</li>
</ul>
</li>
</ul>
</div></section><section><div class="container"><h2 id="nlz-cli">nlz(1)</h2><p><code>nlz(1)</code> is the stopgap CLI tool for normalization proxies.
Eventually, <code>nlz build(1)</code> will be completely optional,
and <code>nlz(1)</code> will primarily be a CLI tool for inspecting your app/component&#39;s dependency tree.</p>
<h3 id="installation">Installation</h3>
<p>Currently, you must install <code>nlz(1)</code> with <code>npm(1)</code>:</p>
<pre><code class="lang-bash">npm <span class="hljs-keyword">install</span> -g nlz
</code></pre>
<p><code>nlz(1)</code> only supports node v0.10,
but you should use node v0.11+ for better performance as generators are extensively used in the source code.</p>
<h3 id="nlz-build">nlz build</h3>
<p>This is the primary build command.
You may think of it as <a href="http://browserify.org">browserify</a>&#39;s build command,
but multiple entry points are supported,
as well as CSS and (eventually) HTML files.</p>
<p>Most of these parameters and options can be set via <code>.nlzrc</code>,
allowing developers to simply run <code>nlz build --watch</code>.</p>
<h4 id="entry-points">Entry Points</h4>
<pre><code class="lang-bash">nlz build [entrypoints...]

<span class="hljs-comment">// will build to build/index.js and build/index.css, respectively</span>
nlz build <span class="hljs-keyword">client</span>/<span class="hljs-keyword">index</span>.js <span class="hljs-keyword">client</span>/<span class="hljs-keyword">index</span>.css
</code></pre>
<h4 id="-out-o">--out, -o</h4>
<p>The destination folder, defaulting to <code>build/</code>.
The destination file will be the same name as the entry point&#39;s file name.</p>
<pre><code class="lang-bash">nlz build <span class="hljs-keyword">client</span>/<span class="hljs-keyword">index</span>.js --out <span class="hljs-keyword">public</span>
</code></pre>
<h4 id="-watch-w">--watch, -w</h4>
<p>Watch the source files for changes and rebuild automatically.
You <strong>should</strong> use this as rebuilds are fast and incremental.
Simply loading <code>nlz(1)</code> takes a considerable amount of time,
especially if you use a lot of transformations.</p>
<pre><code class="lang-bash">nlz build <span class="hljs-keyword">client</span>/<span class="hljs-keyword">index</span>.js --watch
</code></pre>
</div></section><section><div class="container"><h2 id="nlzrc">.nlzrc</h2><p><code>.nlzrc</code> is an optional JSON configuration file for local environments.
It&#39;s completely optional.
You may have a global, <code>.nlzrc</code> configuration for your computer as well as local <code>.nlzrc</code> configuration for each app.
For example, you might want to point all your requests to a proxy on your network instead of <a href="https://nlz.io">https://nlz.io</a>.</p>
<h3 id="-proxy-and-self-signed">.proxy and .self-signed</h3>
<pre><code class="lang-json">{
  "<span class="hljs-attribute">proxy</span>": <span class="hljs-value"><span class="hljs-string">"localhost:8888"</span></span>,
  "<span class="hljs-attribute">self-signed</span>": <span class="hljs-value"><span class="hljs-literal">true</span>
</span>}
</code></pre>
<p>This is to set a custom proxy other than <a href="https://nlz.io">https://nlz.io</a>.
<code>proxy</code> should be the full host, including the port.
Set <code>self-signed</code> to <code>true</code> if the proxy is using a self-signed certification,
otherwise an error will be thrown.
Remember, proxies must always use SSL.</p>
<h3 id="-directory">.directory</h3>
<pre><code class="lang-json">{
  "<span class="hljs-attribute">directory</span>": <span class="hljs-value"><span class="hljs-string">"/User/jong/.repositories"</span>
</span>}
</code></pre>
<p>By default, all files are stored to <code>process.cwd() + &#39;/repositories&#39;</code>.
Thus, every app or component you work on will have its own <code>directory</code> folder.
This may be less than ideal for you as you&#39;ll have multiple copies.</p>
<p>You may optionally set this directory to a global directory like <code>~/.repositories</code>
so that every app or component you work on share the same files.
It will also make installations a little faster.</p>
<h3 id="-transforms">.transforms</h3>
<p>Options for transforms.
<strong>All</strong> transforms are enabled by default.
If you set any <code>.transforms</code> options,
all transforms will now be opt-in.</p>
<p>You shouldn&#39;t need to touch this as transforms&#39; libraries are lazily loaded.
You won&#39;t get much performance benefit from disabling transforms.</p>
<h3 id="-entrypoints">.entrypoints</h3>
<p>The entry points for the build.
This allows you to not specify the entry points every time you run <code>nlz build(1)</code>.</p>
<pre><code class="lang-json">{
  "<span class="hljs-attribute">entrypoints</span>": <span class="hljs-value">[<span class="hljs-string">"client/index.js"</span>, <span class="hljs-string">"client/index.css"</span>]
</span>}
</code></pre>
<p>You may also use objects if you want to set custom options on each entry point:</p>
<pre><code class="lang-json">{
  "<span class="hljs-attribute">entrypoints</span>": <span class="hljs-value">{
    "<span class="hljs-attribute">client/index.js</span>": <span class="hljs-value">{

    }</span>,
    "<span class="hljs-attribute">client/index.css</span>": <span class="hljs-value">{

    }
  </span>}
</span>}
</code></pre>
</div></section><section><div class="container"><h2 id="transforms">Transforms</h2><p>These are all the transforms available for both the normalization proxy and <code>nlz-build(1)</code>.</p>
<p>There are multiple types of transforms which are not mutually exclusive:</p>
<ul>
<li>Build-only - <code>nlz-build(1)</code>-only transforms</li>
<li>Ubiquitus - transforms for both the CLI and the proxy.</li>
<li>1-to-1 - All included in  <a href="https://github.com/normalize/transforms.js">normalize-transforms</a></li>
<li>Global-build-only - Global transforms for <code>nlz-build(1)</code>, specifically CSS transforms.
These are all included in <a href="https://github.com/normalize/build.js">normalize-build</a> and contrast 1-to-1 transforms.</li>
<li>Extension - Extension-based transforms</li>
<li>Tranparent - Transforms without an extension</li>
</ul>
<p>Unlike other bundlers and build systems,
transforms are included automatically.
There are a couple of reasons for this:</p>
<ul>
<li><p>This middleware system is a more complicated than other middleware systems:</p>
<ul>
<li>The use of Koa-based upstream/downstream is quite complex</li>
<li>Order of middleware is very important</li>
<li>Transforms are not orthogonal to another,
so we have to make sure each plugin interacts with each other well.</li>
</ul>
</li>
<li><p>The purpose of normalization is for everyone to be on the same page.
It&#39;s counter productive to have different semantics for the same transform across applications.</p>
</li>
</ul>
<p>PRs for additional transforms are welcomed as long as there&#39;s a valid use-case and people would actually use it.
Feel free to create feature requests and pull requests in the <a href="https://github.com/normalize/transforms.js">transform.js</a> repository.</p>
<h3 id="how-extension-based-transforms-work">How Extension-based Transforms Work</h3>
<p>Given a source file such as <code>template.html</code>,
the walker transforms the file based on additional <code>.&lt;extensions&gt;</code>.
For example, <code>template.html.js</code> will export the HTML string as a JS string.
This is superior because:</p>
<ul>
<li>It&#39;s compatible with HTTP servers</li>
<li>The transforms used are explicitly shown</li>
<li>It allows you to use the same source file in multiple ways without configuration</li>
</ul>
<p>For example, <code>template.jade.js</code> returns a jade render function whereas <code>template.jade.html.js</code> returns the jade template as a compiled string.</p>
<p>You can also compose multiple transforms together.
For example, <code>.jade.html.js</code> is a composition of <code>.jade.html</code> and <code>.html.js</code>.</p>
<p>Unlike other build systems,
transforms have the ability to inject dependencies into your application and automatically install them,
making development easier in general.
For example, to use <code>.jade.js</code>, you need to <a href="https://github.com/facebook/regenerator/blob/master/runtime/dev.js">jade runtime</a>.
The Jade transform will automatically inject the runtime by compiling your jade template to something like this:</p>
<pre><code class="lang-js">module jade from <span class="hljs-string">'https://nlz.io/github/visionmedia/jade/1/lib/runtime.js'</span>

export <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">template</span><span class="hljs-params">(locals)</span> {</span>
  <span class="hljs-comment">// compiled jade</span>
}
</code></pre>
<h3 id="css-transforms">CSS Transforms</h3>
<h4 id="autoprefixer">Autoprefixer</h4>
<p>Type: Transparent, 1-to-1, ubiquitous</p>
<p>All CSS is automatically prefixed using <a href="https://github.com/ai/autoprefixer">autoprefixer</a>.
No extensions are necessary.
The default options are used.</p>
<h4 id="css-variables">CSS Variables</h4>
<p>Type: Global-build-only, transparent</p>
<p>CSS Variables support via <a href="https://github.com/css-utils/variables">variables</a>.</p>
<h4 id="css-color-function">CSS Color Function</h4>
<p>Type: Global-build-only, transparent</p>
<p>CSS color manipulation via <a href="https://github.com/css-utils/colors">css-colors</a>.</p>
<h3 id="js-transforms">JS Transforms</h3>
<h4 id="es6-modules">ES6 Modules</h4>
<p>Type: Build-only, 1-to-1, transparent</p>
<p>All ES6 modules are automatically transpiled to CommonJS modules using <a href="https://github.com/andreypopp/es6-module-jstransform">es6-module-jstransform</a>.
This will be disabled by default once ES6 modules are widely supported by browsers.</p>
<h4 id="regenerator">Regenerator</h4>
<p>Type: Build-only, 1-to-1, transparent</p>
<p>All code that uses generators are automatically transformed using <a href="https://github.com/facebook/regenerator">regenerator</a>.
This will be disabled by default once generators are widely supported by browsers.</p>
<h4 id="-mime-text-js-"><code>.&lt;mime:text/*&gt;.js</code></h4>
<p>Type: Ubiquitous, 1-to-1, extension</p>
<p>All extensions whose corresponding MIME type is <code>text/*</code> are automatically transformed to a JS string using <code>JSON.stringify()</code> unless superceded by another transform.</p>
<pre><code class="lang-js"><span class="hljs-keyword">module</span> <span class="hljs-keyword">text</span> <span class="hljs-keyword">from</span> <span class="hljs-comment">'something.txt'</span>

var el = document.createTextNode()
el.textContent = <span class="hljs-keyword">text</span>
</code></pre>
<h4 id="-json-js-"><code>.json.js</code></h4>
<p>Type: Ubiquitous, 1-to-1, extension</p>
<p>Transforms JSON files to a JS object.</p>
<pre><code class="lang-js"><span class="hljs-keyword">module</span> data <span class="hljs-keyword">from</span> <span class="hljs-string">'data.json'</span>

<span class="hljs-keyword">var</span> name = data.name
</code></pre>
<h3 id="template-transforms">Template Transforms</h3>
<h4 id="-jade-html-"><code>.jade.html</code></h4>
<p>Type: Ubiquitous, 1-to-1, extension</p>
<p>Compile <a href="https://github.com/visionmedia/jade">jade</a> templates to an HTML string.
For example, combined with the <code>.&lt;mime:text/*&gt;.js</code> transform:</p>
<pre><code class="lang-js"><span class="hljs-keyword">module</span> html <span class="hljs-keyword">from</span> <span class="hljs-comment">'template.html.js'</span>

el.innerHTML = html
</code></pre>
<h4 id="-jade-js-"><code>.jade.js</code></h4>
<p>Type: Ubiquitous, 1-to-1, extension</p>
<p>Compile <a href="https://github.com/visionmedia/jade">jade</a> templates to a function.</p>
<pre><code class="lang-js"><span class="hljs-keyword">module</span> render <span class="hljs-keyword">from</span> <span class="hljs-comment">'template.jade.js'</span>
<span class="hljs-keyword">module</span> data <span class="hljs-keyword">from</span> <span class="hljs-comment">'data.json'</span>

el.innerHTML = render(data)
</code></pre>
<h4 id="-md-markdown-html-"><code>.(md|markdown).html</code></h4>
<p>Type: Ubiquitous, 1-to-1, extension</p>
<p>Compile markdown templates to an HTML string using <a href="https://github.com/chjj/marked">marked</a>.
Note that without <code>.html</code>, the actual markdown is returned.</p>
<pre><code class="lang-js"><span class="hljs-keyword">module</span> html <span class="hljs-keyword">from</span> <span class="hljs-comment">'article.md.html.js'</span>

el.innerHTML = html
</code></pre>
<h4 id="-jsx-js-"><code>.jsx.js</code></h4>
<p>Type: Ubiquitous, 1-to-1, extension</p>
<p>Compile <a href="http://facebook.github.io/react/">React</a> <code>.jsx</code> templates to JS.</p>
<h4 id="-html-domify-js-"><code>.html.domify.js</code></h4>
<p>Type: Ubiquitous, 1-to-1, extension</p>
<p>Compile an HTML string to an element using <a href="https://github.com/component/domify">domify</a>.
This is useful for web components and templates.</p>
<pre><code class="lang-js"><span class="hljs-reserved">var</span> template = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./template.html.domify.js'</span>)

<span class="hljs-built_in">document</span>.body.appendChild(template.cloneNode(<span class="hljs-literal">true</span>))
</code></pre>
</div></section><section><div class="container"><h2 id="authoring-javascript">Authoring JavaScript</h2><h3 id="supported-module-systems">Supported Module Systems</h3>
<p>Normalize currently compiles ES6 modules to CommonJS and will do so until all modern browsers support ES6 modules natively.
Thus, Normalize is also able to use CommonJS dependencies.</p>
<p>Normalize does not currently support AMD modules.</p>
<h3 id="differences-with-node-s-commonjs">Differences with Node&#39;s CommonJS</h3>
<p><code>nlz-build(1)</code>&#39;s compiled CommonJS format is a little different than other CommonJS formats such as node, browserify, and component.</p>
<h4 id="you-must-always-specify-the-extension">You must always specify the extension</h4>
<p>In particular, all <code>js</code> files must end with a <code>.js</code> extension.
There are no more magical <code>/index.js</code> or <code>.json</code> look ups.
Imagine, how would this work in the browser?
Multiple HTTP requests would be required, and CSS <code>@import</code>s don&#39;t work this way.</p>
<p>Note that node.js and friends are compatible with <code>.js</code> dependencies,
but it&#39;s a little different with <code>.json</code> files and transforms.</p>
<h4 id="dependencies-use-absolute-urls">Dependencies use absolute URLs</h4>
<p>The purpose of <code>nlz</code> is to use absolute URLs to avoid using <code>.json</code> files and a package manager.
Thus, something like <code>require(&#39;events&#39;)</code> will be rewritten during normalization to <code>require(&#39;https://npmjs.org/-/events/*/index.js&#39;)</code>.
If this is annoying for you, just use browserify.</p>
<h4 id="dependencies-match-html-semantics">Dependencies match HTML semantics</h4>
<p>In Node, <code>require(&#39;file&#39;)</code> means a dependency.
In <code>nlz</code>, if you do <code>require(&#39;file&#39;)</code>,
<code>nlz</code> will actually look for <code>./file</code>,
which is probably nonexistent.
This matches <code>@import</code>, <code>href</code>, and <code>src</code> semantics, so extensions must be included.</p>
<p>However, <code>nlz</code> will simply ignore these as they could be custom modules defined outside the build.</p>
<h3 id="best-practices">Best Practices</h3>
<h4 id="use-index-js-for-browsers-node-js-for-node-js">Use index.js for browsers, node.js for node.js</h4>
<p>Give browsers filename priority and specify <code>.main = &#39;node.js&#39;</code> in your <code>package.json</code>s.</p>
<h4 id="don-t-use-import-or-import-">Don&#39;t use <code>import *</code> or <code>import {}</code></h4>
<p>Stick with <code>module X from &#39;name&#39;</code> and <code>import &#39;name&#39;</code>.
These two methods are the most compatible with CommonJS modules.
ES6 modules are not finalized yet,
so many of these features are subject to change.</p>
</div></section><section><div class="container"><h2 id="authoring-css">Authoring CSS</h2><h3 id="don-ts">Don&#39;ts</h3>
<h4 id="don-t-do-crazy-imports">Don&#39;t do crazy @imports</h4>
<p>Stick with simple <code>@import</code> statements.
<code>@import</code> statements using <code>url()</code>s and media queries are not supported.</p>
</div></section><section><div class="container"><h2 id="bundling">Bundling</h2><p>As shown via <code>nlz build(1)</code>,
you can build multiple entry points, whether <code>.js</code> or <code>.css</code>,
all at the same time.</p>
<pre><code class="lang-bash">nlz build index<span class="hljs-preprocessor">.js</span> something<span class="hljs-preprocessor">.js</span> else<span class="hljs-preprocessor">.js</span>
</code></pre>
<p>However, you probably want a couple of partial bundles,
one for the initial page load and the others for specific pages.</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"boot.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"homepage.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>To do is very simple: have <code>boot.js</code> and <code>homepage.js</code> as entry points
and have <code>homepage.js</code> depend on <code>boot.js</code> directly:</p>
<pre><code class="lang-js"><span class="hljs-comment">// homepage.js:</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'boot.js'</span>
</code></pre>
<p>Then create a build with both entry points:</p>
<pre><code class="lang-bash">nlz build boot<span class="hljs-preprocessor">.js</span> homepage<span class="hljs-preprocessor">.js</span>
</code></pre>
<p>Now you will have to entry points, <code>boot.js</code> and <code>homepage.js</code>.
<code>boot.js</code> will be required to use <code>homepage.js</code>,
and none of <code>boot.js</code>&#39;s dependencies will be included in <code>homepage.js</code>.</p>
<p>If you want to create a single <code>homepage.js</code> bundle,
just build it independently:</p>
<pre><code class="lang-bash">nlz build homepage<span class="hljs-preprocessor">.js</span>
</code></pre>
<p>Now <code>homepage.js</code> will include all of <code>boot.js</code>.</p>
<p>This will work with JS as well as CSS.</p>
<blockquote>
<p>Notes:</p>
<ul>
<li>Common bundles are not yet supported.</li>
<li>All entry points must be defined with their all their dependencies defined prior.</li>
</ul>
</blockquote>
</div></section><section><div class="container"><h2 id="authoring-tests">Authoring Tests</h2><p>One of the goals of Normalize is to make testing easier.
Currently, a lot of CLI tools and integrations with various services are required to test web components well.</p>
<blockquote>
<p>Note: This is not currently implemented and is merely a brainstorm. This is open for discussion.</p>
</blockquote>
<h3 id="tests-will-simply-be-another-entry-point">Tests will simply be another entry point</h3>
<p>Currently, tests are run through CLI utilities such as <code>mocha</code> with many options passed:</p>
<pre><code class="lang-bash"><span class="hljs-comment">mocha</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">reporter</span> <span class="hljs-comment">spec</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">require</span> <span class="hljs-comment">should</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">bail</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">timeout</span> <span class="hljs-comment">10s</span> <span class="hljs-comment">test/*</span><span class="hljs-string">.</span><span class="hljs-comment">js</span>
</code></pre>
<p>Instead, Normalized components should have pure JS entry points for tests:</p>
<pre><code class="lang-js">// get mocha and should globally
import <span class="hljs-string">'https://nlz.io/github/visionmedia/mocha/1/index.js'</span>
import <span class="hljs-string">'https://nlz.io/github/visionmedia/should.js/3/index.js'</span>

// set the test options
mocha.setup(<span class="hljs-string">'bdd'</span>)
mocha.bail()
mocha.reporter(<span class="hljs-string">'spec'</span>)
mocha.timeout(<span class="hljs-string">'10s'</span>)

// include tests within this file
module Component from <span class="hljs-string">'index.js'</span>

describe(<span class="hljs-string">'My Component'</span>, <span class="hljs-keyword">function</span> () {
  // <span class="hljs-keyword">...</span> tests
})

// or simply import other tests
import <span class="hljs-string">'test/this.js'</span>
import <span class="hljs-string">'test/that.js'</span>
</code></pre>
<p>Locally, in node.js environments, running <code>node test.js</code> should be sufficient.
However, some build process might be necessary, so for the near future, it&#39;ll look like:</p>
<pre><code class="lang-bash">nlz build test<span class="hljs-preprocessor">.js</span>
node build/test<span class="hljs-preprocessor">.js</span>
</code></pre>
<h3 id="running-tests-in-browsers">Running tests in browsers</h3>
<p>The above test is only applicable to pure JS modules.
Ideally, we should be able to run tests in browsers,
but browsers require <code>.html</code> documents.
With <code>test.js</code> created above,
users should simply create <code>test.html</code> that references <code>test.js</code>:</p>
<pre><code class="lang-html"><span class="hljs-doctype">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>My Component<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"https://nlz.io/github/visionmedia/mocha/1/index.css"</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>These are the tests!<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"mocha"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"test.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span>
</code></pre>
<p>Thus, simply <code>open test.html</code> <strong>should</strong> run the tests, eventually.
Your test may include additional files such as custom CSS.
For now, we&#39;re going to need a build process to run the tests locally:</p>
<pre><code class="lang-bash">nlz build test<span class="hljs-preprocessor">.html</span>
open build/test<span class="hljs-preprocessor">.html</span>
</code></pre>
<h3 id="running-tests-from-https-nlz-io">Running tests from <a href="https://nlz.io">https://nlz.io</a></h3>
<p>As a build process is required to build the tests locally,
Normalize will automatically <code>nlz build test.js test.html</code> on the server for maximum browser support.
This will make testing browser components easier as you can simply open the <code>test.html</code> file in any browser you&#39;d like:</p>
<pre><code class="lang-bash">open <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/nlz.io/github</span><span class="hljs-regexp">/me/my</span>-component/<span class="hljs-number">1.0</span>.<span class="hljs-number">5</span>/test.html
</code></pre>
<p>When Normalize supports commit SHAs, adding CI support will much simpler.
There won&#39;t be a need to create custom build processes to test your components.
Just create git hooks to open the commit SHA&#39;s tests in different browsers.</p>
<h3 id="scaffolding">Scaffolding</h3>
<p>It would be really annoying to create <code>test.html</code> in every component.
Thus, one of the goals of <a href="https://nlz.io">https://nlz.io</a> is to automatically generate <code>test.html</code> if there&#39;s a <code>test.js</code>.
For example, if <code>mocha</code> is detected as the test runner,
an HTML document with <code>&lt;div id=&quot;mocha&quot;&gt;&lt;/div&gt;</code> and the mocha stylesheet would be created automatically at the proxy.</p>
</div></section><section><div class="container"><h2 id="best-practices">Best Practices</h2><h3 id="keep-your-license-file-separate">Keep your LICENSE file separate</h3>
<p>This will make it easier for the proxy to normalize licenses.
Otherwise, it would have to parse the readme or the JSON files for the correct license.
Plus, it declutters your readme!</p>
</div></section><section><div class="container"><h2 id="troubleshooting">Troubleshooting</h2><h3 id="normalization-logs">Normalization Logs</h3>
<p>The normalization proxy will add logs to two places: <code>normalize-debug.log</code> and each file themselves.</p>
<h4 id="normalize-debug-log">normalize-debug.log</h4>
<p>Each normalized repository will have a <code>normalize-debug.log</code>:</p>
<pre><code><span class="hljs-constant">GET</span> <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/nlz.io/github</span><span class="hljs-regexp">/components/jquery</span><span class="hljs-regexp">/2.1.0/normalize</span>-debug.log
</code></pre><p>This file will contain logs that pertain to the entire repository as a whole.</p>
<h4 id="per-file-logs">Per-file logs</h4>
<p>Each file served from the proxy will include its own logs appended to the bottom of the file.
You can view these comments to see what the proxy did to the file.</p>
<h3 id="debug">Debug</h3>
<p>Whether you&#39;re using <code>nlz(1)</code> or run your own proxy,
you can set the <code>DEBUG</code> environmental variable to view the logs.
See <a href="https://github.com/visionmedia/debug">visionmedia/debug</a> for more usage info.
In particular,
you want to do one of the following:</p>
<pre><code class="lang-bash">DEBUG=<span class="hljs-built_in">normalize</span>*
DEBUG=<span class="hljs-built_in">normalize</span>-proxy*
</code></pre>
<h3 id="common-errors">Common Errors</h3>
<h4 id="emfile-errors">EMFILE Errors</h4>
<p>Normalize does <strong>not</strong> have any concurrency control.
It executes everything as fast as possible in parallel.
What this means is that you could have a lot of file descriptors open at the same time.</p>
<p>Concurrency control is complex and unnecessary for build systems that don&#39;t require concurrency.
If you&#39;re hitting <code>EMFILE</code> errors,
then all you have to do is set your <code>ulimit</code> higher:</p>
<pre><code class="lang-bash">ulimit <span class="hljs-attribute">-n</span> <span class="hljs-number">10000</span>
</code></pre>
<p>There&#39;s no reason you should have low limits in development.</p>
</div></section><section><div class="container"><h2 id="production-checklist">Production Checklist</h2><p><a href="https://nlz.io">https://nlz.io</a> is <strong>NOT</strong> ready to be used as a CDN in production.
You may still use it as a registry and proxy for <code>nlz(1)</code>,
but serving files from <a href="https://nlz.io">https://nlz.io</a> is not recommended.</p>
<p>The following criteria must be met before it is ready for production usage:</p>
<ul>
<li>A CDN that supports SPDY Push must be used. We&#39;re not going to setup a complex infrastructure to make this work (like npm).</li>
<li>Browsers must support SPDY</li>
<li>Browsers must support URLs in ES6 module <code>import</code> statements</li>
<li>Browsers must support <code>&lt;link rel=&quot;import&quot; href=&quot;&quot;&gt;</code> tags</li>
</ul>
</div></section><section><div class="container"><h2 id="comparisons">Comparisons</h2><h3 id="bundling-vs-browserify">Bundling vs. Browserify</h3>
<p><code>nlz build(1)</code> is pretty similar to Browserify.
How does the bundling compare?
Let&#39;s compare the created bundles for <a href="https://github.com/barberboy/dom-elements">dom-elements</a>.
We&#39;ll do basic builds, minification, and compression.
You can view the <a href="https://github.com/normalize/comparisons/blob/master/Makefile">Makefile</a>.</p>
<table>
<thead>
<tr>
<th>Build</th>
<th>Normalize</th>
<th>Browserify</th>
</tr>
</thead>
<tbody>
<tr>
<td>.js</td>
<td>10,525b</td>
<td>6,625b</td>
</tr>
<tr>
<td>.min.js</td>
<td>5,494b</td>
<td>3,425b</td>
</tr>
<tr>
<td>.min.js.gz</td>
<td>1,292b</td>
<td>1,328b</td>
</tr>
</tbody>
</table>
<p>What you&#39;ll see is that Normalize&#39;s JS builds are larger than Browserify&#39;s.
This is due to a couple of reasons:</p>
<ol>
<li>Normalize doesn&#39;t automatically minimize the <code>require()</code> implementation.
Doing so unnecessarily hides the magic from developers.</li>
<li>Normalize doesn&#39;t wrap the build within a closure.
Developers can do that themselves.
This allows developers to <code>require(&#39;./index.js&#39;)</code> outside the build.</li>
<li>Normalize uses the full URL for dependencies.
<code>require(&#39;../utils/separate-selector.js&#39;)</code> is expanded to <code>require(&#39;https://nlz.io/github/barberboy/dom-elements/0.1.0/src/utils/separate-selector.js&#39;)</code>.</li>
<li>Normalize adds comments to each file for debugging.</li>
</ol>
<p>But then you&#39;ll notice that Normalize&#39;s gzip build is actually smaller than browserify&#39;s.
In the end, the gzip size is all that matters.
This is primarily due to two reasons:</p>
<ol>
<li>Absolute URLs are mostly redundant and very compressible.</li>
<li>The <code>require()</code> implementation is minimal and is basically just a hash lookup.</li>
</ol>
</div></section><section><div class="container"><h2 id="philosophy">Philosophy</h2><p>Normalize.IO was born out of frustration with the current web development workflow.
It has a very specific philosophy,
which will affect its development.</p>
<p>Wondering if Normalize.IO should add a feature?
If it complies with these tenets, then let us know!
Otherwise, don&#39;t bother.</p>
<h3 id="back-to-the-basics">Back to the Basics</h3>
<p>The web development stack should be as short as possible.
This means no unnecessary abstractions or opinions and just use what W3C, WHATWG, and ES has given us.
Build tools like LESS, CoffeeScript, and Grunt are second-class citizens.</p>
<p>Let&#39;s not try to build the ideal stack of <code>npm + browserify + less + rework-npm + gulp + yeoman</code>, etc.
We should strive towards <strong>no stack</strong> using only features browsers (will) support,
and at most 1 tool, <code>nlz</code> or anything similar, as a stopgap until browsers get us there.</p>
<h3 id="specification-compliant">Specification Compliant</h3>
<p>Normalize.IO will strive to comply with specifications from the web authorities,
particularly ECMAScript, WHATWG, and W3C.
Specifications like CommonJS, AMD, and UMD are completely irrelevant and are only used as stopgaps for the true specifications.</p>
<p>Thus, you may see features such as <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables">CSS Variables</a> and <a href="http://facebook.github.io/regenerator/">regenerator</a> automatically included, acting like polyfills.
But you will not see features such as <a href="https://github.com/reworkcss/rework-inherit">@extend</a> included unless they are added to the specifications, even as a draft.</p>
<h3 id="opt-in-everything">Opt-In Everything</h3>
<p>Many build systems such as <code>grunt</code>, <code>gulp</code>, <code>broccoli</code>, <code>browserify</code>, and <code>component</code> have a lot of possible plugins and configuration options.
However, these have become a bane for web development as now users have to install tens of modules just to get their app running
as well as figure out how to configure all these plugins to work with each other with giant configuration scripts.
Developers would also have to write plugins for every time of platform,
creating what I call &quot;module pollution&quot;.</p>
<p>The Normalize.IO philosophy is the opposite - it should include all plugins that 99% of web developers use,
allowing most to be able to just simply <code>nlz build --watch</code> their component or app and call it a day.
Eventually, they should be able to skip <code>nlz</code> and simply <code>open webpage.html</code>.
Bootstrapping apps and components should not be complicated.</p>
<p>This means that Normalize.IO will marginalize those 1% of developers who want something very specific and most likely outside of specifications.
If the 1% wishes to use Normalize.IO, they would have to essentially create their own custom proxy and client to do so.
Otherwise, they could use the many other build tools at their disposal.</p>
<h3 id="normalize-web-development">Normalize Web Development</h3>
<p>Aside from the top three tenets,
the idea behind Normalize.IO is to &quot;normalize&quot; or &quot;standardize&quot; web development.
We want to keep features specification compliant and (cognitive) overhead minimal.</p>
<p>But of course, this means normalizing and standardizing how apps and components are built and structured.
This is the primary concept behind <code>entrypoints</code> such as <code>index.js</code>, <code>test.js</code>, <code>README</code>, etc.
People should know what to expect from a &quot;normal&quot; app/module/component.</p>
<h3 id="1-to-1-transformations">1-to-1 Transformations</h3>
<p>One of the most complicated type of transform are many-to-1 transforms.
For example, concatenating all your SCSS files, then converting it to a single CSS file.
However there are many wrong with this philosophy.</p>
<p>Normalize.IO will only support 1-to-1 transformations except for a few cases,
but most likely with caveats.</p>
<h4 id="file-interdependence">File Interdependence</h4>
<p>The only dependencies files should have upon each other are those defined by specifications such as <code>@import</code>.
Anything else is too opinionated for Normalize.IO.
With CSS preprocessors, this may be necessary when using mixins, variables, etc.,
but you should instead strive towards specifications such as <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables">CSS Variables</a>.</p>
<h4 id="no-incremental-builds">No Incremental Builds</h4>
<p>Only supporting 1-to-1 transformations allow very fast build times through incremental builds.
<code>nlz</code> uses <code>make</code>-like 1-to-1 transforms and only rebuilds source files that have changed.
When you have many-to-one transforms, 1 line change would require a full rebuild.
The difference is a <code>x * 100ms</code> vs. <code>&lt; 100ms</code> build times,
especially with CSS preprocessors such as Stylus and SASS.</p>
<h4 id="no-complicated-build-process">No Complicated Build Process</h4>
<p>Many build tools such as <code>grunt</code>, <code>gulp</code>, and <code>broccoli</code> were created out of a need to support these types of transforms.
In the end, you create very complex build processes and configuration options,
all of which is unnecessary and not specification-compliant.</p>
</div></section><section><div class="container"><h2 id="faq">Frequently Asked Questions</h2><h3 id="how-will-you-make-money-">How will you make money?</h3>
<p>Currently, Normalize.IO is being developed as a build process for my own app.
Thus, only features I use will be actively developed by my own free will.</p>
<p>For long term support, you should <a href="https://www.gittip.com/jonathanong/">gittip me</a> as hosting costs are at least $100 a year,
half of which is just the domain name.
If tipped, I&#39;ll be inclined to work on features I don&#39;t use.</p>
<p>For business and enterprise features,
you&#39;ll probably want to set a bounties via <a href="https://www.bountysource.com/">bountysource</a> or contact me directly for paid support.
All my code is open source, so I personally don&#39;t have a need for these types of features, but I believe these are eventually necessary.</p>
<p>If Normalize.IO takes off, I&#39;d like to create a &quot;proxy as a service&quot; much like nodejitsu&#39;s private npm servers,
but I wouldn&#39;t want to do it myself since I have no interest in dev ops.</p>
<p>I&#39;m particularly interested in corporate sponsorships,
particularly the first CDN that could provide SPDY Push support.</p>
<h3 id="will-normalize-io-support-node-js-">Will Normalize.IO support node.js?</h3>
<p>Hopefully, node.js will eventually support <a href="https://nlz.io">https://nlz.io</a> without a client with ES6 modules.
But supporting node.js with a command line interface is difficult as there are many obstacles to overcome.
Basically, forking node would be required to make it work gracefully, which is in the realm of possibility.</p>
<p>To keep yourself up to date with node.js support,
follow the <a href="https://github.com/normalize/node-normalize">node-normalize</a> repository.</p>
<h3 id="can-i-omit-https-from-the-urls-">Can I omit <code>https://</code> from the URLs?</h3>
<p>If browsers support protocol-less URLs, then so will we.
However, there are a couple potential issues with omitting protocols.</p>
<ol>
<li>It&#39;s more difficult to differentiate between URLs and local/relative assets.</li>
<li>Some browsers plan to not support non-SSL SPDY, so this might even work in development.</li>
</ol>
</div></section></main><footer><div class="container"><div id="footer-badges"><script data-gittip-username="jonathanong" src="https://gttp.co/v1.js" async></script></div><ul id="footer-links"><li>Jonathan Ong &copy; 2014</li><li><a href="http://jongleberry.com">jongleberry.com</a></li><li><a href="https://github.com/jonathanong">@jonathanong</a></li><li><a href="https://twitter.com/jongleberry">@jongleberry</a></li><li><a href="mailto:me@jongleberry.com">me@jongleberry.com</a></li></ul></div></footer><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-7367759-13', 'normalize.github.io');
ga('send', 'pageview');
</script><script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script><script src="index.js"></script></body></html>