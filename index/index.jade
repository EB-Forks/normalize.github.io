
extends ../layout

block header
  .container
    h1 normalize.io
      small  &beta;eta
    p
      small <code>@import</code> the future, <code>nlz-build(1)</code> the present, <code>normalize</code> the past.
    p.
      An ES6 Module, Web Component, and SPDY/HTTP2 frontend development workflow.
    a#to-source.m-btn.green(href='https://github.com/normalize/normalize.github.io') Show Me an Example!
    p.
      The frontend development workflow has fundamentally changed with the advent of ES6 modules, HTML imports, and SPDY/HTTP2 push.
      Normalize provides tools for this much simpler workflow as well as "normalizes" (polyfilling/transpiling/etc.) for older browsers so that you can still build today.

block main
  section: .container
    h3(id='no-installation-step') No Installation Step with ES6 Modules and HTML Imports
    :markdown
      With ES6 modules and HTML imports, you can define dependencies just like CSS `@import` statements.
      When creating static pages or libraries, simply use URLs and open your browser:

      ```js
      import Ember from 'https://nlz.io/github/components/ember/^1.0.0/ember.js';
      ```

      You may also use shorthands instead, which require a custom module loader (for JS, only) or a build process (such as a SPDY Push server):

      ```js
      import $ from 'jquery@^2.0.0'; // from npm
      import Emitter from 'component/emitter@^1.0.0'; // from GitHub
      ```

      ```css
      @import 'https://nlz.io/github/necolas/normalize.css/^3.0.0/index.css';
      @import 'necolas/normalize@^3.0.0';
      ```

      ```html
      <link rel="import" href="https://nlz.io/github/webcomponents/hello-world-elements/*/index.html">
      <link rel="import" href="webcomponents/hello-world-elements@*">
      ```

      Package management (i.e. versioning) is performed through [normalization proxies](https://github.com/normalize/proxy.js),
      such as https://nlz.io, as URLs.
      There are no more JSON files to declare dependencies in - just inline them in your code.
      If you wish to use private modules, simply setup your own proxy!

    h3(id='no-concatenation-step') No Concatenation Step with SPDY Push
    :markdown
      SPDY push allows websites to avoid a concatenation step - just SPDY push all your assets!
      Previously, concatenation steps were required to avoid unnecessary HTTP roundtrips,
      but this latency is nonexistent with SPDY push!
      However, [`nlz(1)`](https://github.com/normalize/nlz) still includes a concatenation step if you still wish to create bundles.

      - [koa-normalize](https://github.com/normalize/koa.js) - a SPDY push server for [koa](https://koajs.com)
      - [koala](https://github.com/koajs/koala) - a [koa](https://koajs.com) framework that includes [koa-normalize](https://github.com/normalize/koa.js)

    h3(id='future-syntax-everywhere') Future Syntax, Everywhere
    :markdown
      Normalize allows you to use the latest language features, such as ES6 modules,
      generators, or `requestAnimationSupport`, while still supporting
      almost all browsers with minimal effort. It does so in two ways:

      Normalize servers include [polyfills/polyfills](https://github.com/polyfills/polyfills),
      which create JS polyfill bundles specific to each browser.

      Normalize includes [ecstacy](https://github.com/polyfills/ecstacy),
      which transpiles newer JS and CSS syntaxes to a syntax the client
      can use. Use generators, ES6 modules, you name it, with ease.

    h3(id='no-transpilation-step') No Transpilation Step!
    :markdown
      Normalize automatically supports your favorite transpiled languages.
      These [transforms](api.html#transforms) are URL-based,
      allowing them to be HTTP-compliant as well as more declarative.
      All adapters are included - you simply need to install the underlying library yourself.

      For example, suppose you have `template.jsx`, a [react](http://facebook.github.io/react/) template.
      You could simply do:

      ```js
      import 'template.jsx'
      ```

      And that template is imported! Of course, you need to install `react-tools` first.

    h3(id='no-json-or-config-files') No JSON or configuration files!
    :markdown
      Normalize does not have any mandatory JSON files or configuration files,
      although you may still decide to use them.
      There's no `package.json` or `bower.json` to create a manifest or to publish
      your package anywhere, although you still could.
      There's no `gulpfile.js` or `gruntfile.js` to setup your build process.
      Start building right away and use any package you'd like!

    h3(id='package-normalization') Use Browserify Packages or Components Seamlessly
    :markdown
      Normalize supports [browserify](http://browserify.org) packages
      as well as [components](https://github.com/component) seamlessly.
      Normalize will automatically shim node modules just like browserify does.
      This allows you to use existing components, whether or not they are ES6 modules,
      today.

      Normalize does __not__ support AMD modules - only CommonJS/UMD modules.

    h3(id='minimal-runtime-overhead') Minimal Runtime Overhead
    :markdown
      Unlike other ES6 module tools, Normalize does not require large client-side
      loaders like [RequireJS](http://requirejs.org) or large polyfills
      like [es6-module-loader](https://github.com/ModuleLoader/es6-module-loader).
      Writing modules with boilerplate nesting defeats the purpose of ES6 modules.
